250226 Testing functions

Works:


var name = "Timmy";

fun sayHi() {
   print name;
}

sayHi();

Not work: semicolon issue;
function add5(num) {
  return num + 5;
}

var result = add5(6);

print result;


// This owrks after I stop cloning env
var num = 1;
num = 11;

print num;

if (3 == 5) {
  print "first";
  num = 5;
  print "second";
}

if (true) {
  print "inside true";
}

if (false) {
  print "inside false";
}

print num;

/////

This works after I stop cloning ENV

var num = 9;

print "start";

while (num < 10) {
  num = 10;
}

print "num at end";
print num;
print "end";

////

// This does NOT work just when switching the env;
// NOW it works that I put evaluation of assignment into evaluate()
var num = 0;

print "start";

while (num < 10) {
  print num;
  num = num + 1;
}

print "end";
print num;

-----
250305 Testing returns


NOT WORK:

fun add(a, b) {
  return a + b;
}

var result = add(3, 5);

print result;

WORKS:

var fish = "salmon";
print fish;

THIS ALSO WORKS:

fun work() {
  var fish = "salmon";
  print fish;
}

work();

THIS WORKS!

fun add(a, b) {
  return a + b;
}

print add(3, 5);

SO WHY DOES THIS NOT WORK?

Now this works...

fun add(a, b) {
  return a + b;
}

print add(7, 8);

var result = add(3, 5);

print result;

I had to move the setting of the function identifier in the env
outide the evaluate() call. To add this to lessons learned.
Note: this is similar to what had to happen other times the
`set` function was called: the setting never happened inside an
evaluate call. It happened outside.


-----

this does not work

fun add(a, b) {
  print a + b;
  return fun divide(a, b) {
    return a / b;
  };
}

print add(10, 5)();


This works

fun whoopie(num) {
  if (num == 0) {
    return "whoopie!";
  }
}

var result = whoopie(0);

print result;


DOES NOT WORK -- why??


fun whoopie(num) {
  if (num == 0) {
    print "whoopie!";
  }
  print num;
  print num - 1;
  var newNum = num - 1;
  print newNum;
}

// UPTO here, trying to figure out
// why this fails. I need a step-through
// debugger
whoopie(10);


BUT this works

fun whoopie(num) {
  if (num == 0) {
    print "whoopie!";
  }
  print num - 1;
}

whoopie(10);

fun whoopie(num) {
  print num;
  print num - 1;
  var newNum = num - 1;
  print newNum;
}

whoopie(5);

------

This works after I move all set/update/get to inside
evaluate calls

THAT FIXES THE PROBLEM ABOVE TOO! This one:
fun whoopie(num) {
  print num;
  print num - 1;
  var newNum = num - 1;
  print newNum;
}

whoopie(5);

This also works now! these may be decent test cases

fun whoopie(num) {
  if (num == 0) {
    return "whoopie!";
  }
  return 6;
}

var result = whoopie(0);

print result;

var result1 = whoopie(7);
print result1;

This does not work, but I don't expect it to

fun whoopie(num) {
  if (num == 0) {
    return "whoopie!";
  }
  return 6;
}

var result = whoopie(0);

print result;

var result1 = whoopie(7);
print result1;

------

This works! Recursion!

fun add(a, b) {
  if (a + b > 100) {
    print "overload!";
    return;
  }
  print a + b;
  var newFirst = a + a;
  var newSecond = b + b;
  add(newFirst, newSecond);
}

print add(2, 3);

ADD TEST BASED ON THIS
fun add(a, b) {
  if (a + b > 100) {
    print "overload!";
    return;
  }
  print a + b;
  var newFirst = a + a;
  var newSecond = b + b;
  add(newFirst, newSecond);
}

print add(2, 3);

-----

fun returnFive() {
  return 5;
}

var result1 = returnFive();

var result2 = result1 + 7;

print result2;


-----
works!

fun makeCounter() {
  var i = 0;
  fun count() {
    i  = i + 1;
    print i;
  }

  return count;
}

var counter = makeCounter();
counter();
counter();

    console.dir({ primaryNode }, { depth: null });
  // tokens.forEach((t,i) => {
  //   console.dir(i)
  //   console.dir(t)
  // })

fun fib(n) {
  if (n <= 1) return n;
  return fib(n - 2) + fib(n - 1);
}

// THIS is not working for some reason
for (var i = 0; i < 20; i = i + 1) {
  print i;
}

// something seems wrong with my conditions;
fun fib(n) {
  print n;
  if (n <= 1) {
    return n;
  }

  return fib(n - 2) + fib(n - 1);
}

print fib(20);

Works

var n = 3;

fun analyze() {
  var result;

  if (n > 4) {
    print "greater!";
  }

  if (n == 4) {
    print "equal!";
  }

  if (n < 4) {
    print "less than!";
    result = "good!";
  }

  if (n <= 4) {
    print "less than or equal!";
  }

  if (n >= 4) {
    print "greater than or equal!";
  }

  return result;
}

var result = analyze();

print result;
