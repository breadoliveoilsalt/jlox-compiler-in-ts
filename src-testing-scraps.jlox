

This works! Recursion!

fun add(a, b) {
  if (a + b > 100) {
    print "overload!";
    return;
  }
  print a + b;
  var newFirst = a + a;
  var newSecond = b + b;
  add(newFirst, newSecond);
}

print add(2, 3);

ADD TEST BASED ON THIS
fun add(a, b) {
  if (a + b > 100) {
    print "overload!";
    return;
  }
  print a + b;
  var newFirst = a + a;
  var newSecond = b + b;
  add(newFirst, newSecond);
}

print add(2, 3);

-----

fun returnFive() {
  return 5;
}

var result1 = returnFive();

var result2 = result1 + 7;

print result2;


-----
works!

fun makeCounter() {
  var i = 0;
  fun count() {
    i  = i + 1;
    print i;
  }

  return count;
}

var counter = makeCounter();
counter();
counter();

    console.dir({ primaryNode }, { depth: null });
  // tokens.forEach((t,i) => {
  //   console.dir(i)
  //   console.dir(t)
  // })

fun fib(n) {
  if (n <= 1) return n;
  return fib(n - 2) + fib(n - 1);
}

// THIS is not working for some reason
for (var i = 0; i < 20; i = i + 1) {
  print i;
}

// something seems wrong with my conditions;
fun fib(n) {
  print n;
  if (n <= 1) {
    return n;
  }

  return fib(n - 2) + fib(n - 1);
}

print fib(20);

Works

var n = 3;

fun analyze() {
  var result;

  if (n > 4) {
    print "greater!";
  }

  if (n == 4) {
    print "equal!";
  }

  if (n < 4) {
    print "less than!";
    result = "good!";
  }

  if (n <= 4) {
    print "less than or equal!";
  }

  if (n >= 4) {
    print "greater than or equal!";
  }

  return result;
}

var result = analyze();

print result;

------
For loops work


But for this

...I'm getting this result. AND the reason is that my value for n is getting polluted. That is, in the last line, the first call to fib is getting run and returned, BUT when it gets to the second call fib, it's the SAME env...that is, the first time fib(n-1) is called, n is 0! when it should be 20


fun fib(n) {
  print n;
  if (n <= 1) {
    return n;
  }

  return fib(n - 2) + fib(n - 1);
}

fib(20);
20
18
16
...
-1
-2
...
-10
  print n;
  print n;
